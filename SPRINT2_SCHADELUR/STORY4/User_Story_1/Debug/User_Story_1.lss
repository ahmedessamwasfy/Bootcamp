
User_Story_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000bd6  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000c4a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001c  00800060  00800060  00000c4a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000c4a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000c7c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000100  00000000  00000000  00000cb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000bee  00000000  00000000  00000db8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008a8  00000000  00000000  000019a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000823  00000000  00000000  0000224e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002c8  00000000  00000000  00002a74  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004e6  00000000  00000000  00002d3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000521  00000000  00000000  00003222  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  00003743  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 79 05 	jmp	0xaf2	; 0xaf2 <__vector_10>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e6 ed       	ldi	r30, 0xD6	; 214
  68:	fb e0       	ldi	r31, 0x0B	; 11
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a0 36       	cpi	r26, 0x60	; 96
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a0 e6       	ldi	r26, 0x60	; 96
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ac 37       	cpi	r26, 0x7C	; 124
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <main>
  8a:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
  98:	cd b7       	in	r28, 0x3d	; 61
  9a:	de b7       	in	r29, 0x3e	; 62
  9c:	89 83       	std	Y+1, r24	; 0x01
  9e:	6a 83       	std	Y+2, r22	; 0x02
  a0:	89 81       	ldd	r24, Y+1	; 0x01
  a2:	88 30       	cpi	r24, 0x08	; 8
  a4:	60 f5       	brcc	.+88     	; 0xfe <DIO_WritePin+0x6c>
  a6:	8a 81       	ldd	r24, Y+2	; 0x02
  a8:	88 23       	and	r24, r24
  aa:	a9 f4       	brne	.+42     	; 0xd6 <DIO_WritePin+0x44>
  ac:	8b e3       	ldi	r24, 0x3B	; 59
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	2b e3       	ldi	r18, 0x3B	; 59
  b2:	30 e0       	ldi	r19, 0x00	; 0
  b4:	f9 01       	movw	r30, r18
  b6:	60 81       	ld	r22, Z
  b8:	29 81       	ldd	r18, Y+1	; 0x01
  ba:	42 2f       	mov	r20, r18
  bc:	50 e0       	ldi	r21, 0x00	; 0
  be:	21 e0       	ldi	r18, 0x01	; 1
  c0:	30 e0       	ldi	r19, 0x00	; 0
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <DIO_WritePin+0x36>
  c4:	22 0f       	add	r18, r18
  c6:	33 1f       	adc	r19, r19
  c8:	4a 95       	dec	r20
  ca:	e2 f7       	brpl	.-8      	; 0xc4 <DIO_WritePin+0x32>
  cc:	20 95       	com	r18
  ce:	26 23       	and	r18, r22
  d0:	fc 01       	movw	r30, r24
  d2:	20 83       	st	Z, r18
  d4:	b0 c0       	rjmp	.+352    	; 0x236 <DIO_WritePin+0x1a4>
  d6:	8b e3       	ldi	r24, 0x3B	; 59
  d8:	90 e0       	ldi	r25, 0x00	; 0
  da:	2b e3       	ldi	r18, 0x3B	; 59
  dc:	30 e0       	ldi	r19, 0x00	; 0
  de:	f9 01       	movw	r30, r18
  e0:	60 81       	ld	r22, Z
  e2:	29 81       	ldd	r18, Y+1	; 0x01
  e4:	42 2f       	mov	r20, r18
  e6:	50 e0       	ldi	r21, 0x00	; 0
  e8:	21 e0       	ldi	r18, 0x01	; 1
  ea:	30 e0       	ldi	r19, 0x00	; 0
  ec:	02 c0       	rjmp	.+4      	; 0xf2 <DIO_WritePin+0x60>
  ee:	22 0f       	add	r18, r18
  f0:	33 1f       	adc	r19, r19
  f2:	4a 95       	dec	r20
  f4:	e2 f7       	brpl	.-8      	; 0xee <DIO_WritePin+0x5c>
  f6:	26 2b       	or	r18, r22
  f8:	fc 01       	movw	r30, r24
  fa:	20 83       	st	Z, r18
  fc:	9c c0       	rjmp	.+312    	; 0x236 <DIO_WritePin+0x1a4>
  fe:	89 81       	ldd	r24, Y+1	; 0x01
 100:	88 30       	cpi	r24, 0x08	; 8
 102:	88 f1       	brcs	.+98     	; 0x166 <DIO_WritePin+0xd4>
 104:	89 81       	ldd	r24, Y+1	; 0x01
 106:	80 31       	cpi	r24, 0x10	; 16
 108:	70 f5       	brcc	.+92     	; 0x166 <DIO_WritePin+0xd4>
 10a:	8a 81       	ldd	r24, Y+2	; 0x02
 10c:	88 23       	and	r24, r24
 10e:	b1 f4       	brne	.+44     	; 0x13c <DIO_WritePin+0xaa>
 110:	88 e3       	ldi	r24, 0x38	; 56
 112:	90 e0       	ldi	r25, 0x00	; 0
 114:	28 e3       	ldi	r18, 0x38	; 56
 116:	30 e0       	ldi	r19, 0x00	; 0
 118:	f9 01       	movw	r30, r18
 11a:	60 81       	ld	r22, Z
 11c:	29 81       	ldd	r18, Y+1	; 0x01
 11e:	28 50       	subi	r18, 0x08	; 8
 120:	42 2f       	mov	r20, r18
 122:	50 e0       	ldi	r21, 0x00	; 0
 124:	21 e0       	ldi	r18, 0x01	; 1
 126:	30 e0       	ldi	r19, 0x00	; 0
 128:	02 c0       	rjmp	.+4      	; 0x12e <DIO_WritePin+0x9c>
 12a:	22 0f       	add	r18, r18
 12c:	33 1f       	adc	r19, r19
 12e:	4a 95       	dec	r20
 130:	e2 f7       	brpl	.-8      	; 0x12a <DIO_WritePin+0x98>
 132:	20 95       	com	r18
 134:	26 23       	and	r18, r22
 136:	fc 01       	movw	r30, r24
 138:	20 83       	st	Z, r18
 13a:	7d c0       	rjmp	.+250    	; 0x236 <DIO_WritePin+0x1a4>
 13c:	88 e3       	ldi	r24, 0x38	; 56
 13e:	90 e0       	ldi	r25, 0x00	; 0
 140:	28 e3       	ldi	r18, 0x38	; 56
 142:	30 e0       	ldi	r19, 0x00	; 0
 144:	f9 01       	movw	r30, r18
 146:	60 81       	ld	r22, Z
 148:	29 81       	ldd	r18, Y+1	; 0x01
 14a:	28 50       	subi	r18, 0x08	; 8
 14c:	42 2f       	mov	r20, r18
 14e:	50 e0       	ldi	r21, 0x00	; 0
 150:	21 e0       	ldi	r18, 0x01	; 1
 152:	30 e0       	ldi	r19, 0x00	; 0
 154:	02 c0       	rjmp	.+4      	; 0x15a <DIO_WritePin+0xc8>
 156:	22 0f       	add	r18, r18
 158:	33 1f       	adc	r19, r19
 15a:	4a 95       	dec	r20
 15c:	e2 f7       	brpl	.-8      	; 0x156 <DIO_WritePin+0xc4>
 15e:	26 2b       	or	r18, r22
 160:	fc 01       	movw	r30, r24
 162:	20 83       	st	Z, r18
 164:	68 c0       	rjmp	.+208    	; 0x236 <DIO_WritePin+0x1a4>
 166:	89 81       	ldd	r24, Y+1	; 0x01
 168:	80 31       	cpi	r24, 0x10	; 16
 16a:	88 f1       	brcs	.+98     	; 0x1ce <DIO_WritePin+0x13c>
 16c:	89 81       	ldd	r24, Y+1	; 0x01
 16e:	88 31       	cpi	r24, 0x18	; 24
 170:	70 f5       	brcc	.+92     	; 0x1ce <DIO_WritePin+0x13c>
 172:	8a 81       	ldd	r24, Y+2	; 0x02
 174:	88 23       	and	r24, r24
 176:	b1 f4       	brne	.+44     	; 0x1a4 <DIO_WritePin+0x112>
 178:	85 e3       	ldi	r24, 0x35	; 53
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	25 e3       	ldi	r18, 0x35	; 53
 17e:	30 e0       	ldi	r19, 0x00	; 0
 180:	f9 01       	movw	r30, r18
 182:	60 81       	ld	r22, Z
 184:	29 81       	ldd	r18, Y+1	; 0x01
 186:	20 51       	subi	r18, 0x10	; 16
 188:	42 2f       	mov	r20, r18
 18a:	50 e0       	ldi	r21, 0x00	; 0
 18c:	21 e0       	ldi	r18, 0x01	; 1
 18e:	30 e0       	ldi	r19, 0x00	; 0
 190:	02 c0       	rjmp	.+4      	; 0x196 <DIO_WritePin+0x104>
 192:	22 0f       	add	r18, r18
 194:	33 1f       	adc	r19, r19
 196:	4a 95       	dec	r20
 198:	e2 f7       	brpl	.-8      	; 0x192 <DIO_WritePin+0x100>
 19a:	20 95       	com	r18
 19c:	26 23       	and	r18, r22
 19e:	fc 01       	movw	r30, r24
 1a0:	20 83       	st	Z, r18
 1a2:	49 c0       	rjmp	.+146    	; 0x236 <DIO_WritePin+0x1a4>
 1a4:	85 e3       	ldi	r24, 0x35	; 53
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	25 e3       	ldi	r18, 0x35	; 53
 1aa:	30 e0       	ldi	r19, 0x00	; 0
 1ac:	f9 01       	movw	r30, r18
 1ae:	60 81       	ld	r22, Z
 1b0:	29 81       	ldd	r18, Y+1	; 0x01
 1b2:	20 51       	subi	r18, 0x10	; 16
 1b4:	42 2f       	mov	r20, r18
 1b6:	50 e0       	ldi	r21, 0x00	; 0
 1b8:	21 e0       	ldi	r18, 0x01	; 1
 1ba:	30 e0       	ldi	r19, 0x00	; 0
 1bc:	02 c0       	rjmp	.+4      	; 0x1c2 <DIO_WritePin+0x130>
 1be:	22 0f       	add	r18, r18
 1c0:	33 1f       	adc	r19, r19
 1c2:	4a 95       	dec	r20
 1c4:	e2 f7       	brpl	.-8      	; 0x1be <DIO_WritePin+0x12c>
 1c6:	26 2b       	or	r18, r22
 1c8:	fc 01       	movw	r30, r24
 1ca:	20 83       	st	Z, r18
 1cc:	34 c0       	rjmp	.+104    	; 0x236 <DIO_WritePin+0x1a4>
 1ce:	89 81       	ldd	r24, Y+1	; 0x01
 1d0:	88 31       	cpi	r24, 0x18	; 24
 1d2:	88 f1       	brcs	.+98     	; 0x236 <DIO_WritePin+0x1a4>
 1d4:	89 81       	ldd	r24, Y+1	; 0x01
 1d6:	80 32       	cpi	r24, 0x20	; 32
 1d8:	70 f5       	brcc	.+92     	; 0x236 <DIO_WritePin+0x1a4>
 1da:	8a 81       	ldd	r24, Y+2	; 0x02
 1dc:	88 23       	and	r24, r24
 1de:	b1 f4       	brne	.+44     	; 0x20c <DIO_WritePin+0x17a>
 1e0:	82 e3       	ldi	r24, 0x32	; 50
 1e2:	90 e0       	ldi	r25, 0x00	; 0
 1e4:	22 e3       	ldi	r18, 0x32	; 50
 1e6:	30 e0       	ldi	r19, 0x00	; 0
 1e8:	f9 01       	movw	r30, r18
 1ea:	60 81       	ld	r22, Z
 1ec:	29 81       	ldd	r18, Y+1	; 0x01
 1ee:	28 51       	subi	r18, 0x18	; 24
 1f0:	42 2f       	mov	r20, r18
 1f2:	50 e0       	ldi	r21, 0x00	; 0
 1f4:	21 e0       	ldi	r18, 0x01	; 1
 1f6:	30 e0       	ldi	r19, 0x00	; 0
 1f8:	02 c0       	rjmp	.+4      	; 0x1fe <DIO_WritePin+0x16c>
 1fa:	22 0f       	add	r18, r18
 1fc:	33 1f       	adc	r19, r19
 1fe:	4a 95       	dec	r20
 200:	e2 f7       	brpl	.-8      	; 0x1fa <DIO_WritePin+0x168>
 202:	20 95       	com	r18
 204:	26 23       	and	r18, r22
 206:	fc 01       	movw	r30, r24
 208:	20 83       	st	Z, r18
 20a:	15 c0       	rjmp	.+42     	; 0x236 <DIO_WritePin+0x1a4>
 20c:	82 e3       	ldi	r24, 0x32	; 50
 20e:	90 e0       	ldi	r25, 0x00	; 0
 210:	22 e3       	ldi	r18, 0x32	; 50
 212:	30 e0       	ldi	r19, 0x00	; 0
 214:	f9 01       	movw	r30, r18
 216:	60 81       	ld	r22, Z
 218:	29 81       	ldd	r18, Y+1	; 0x01
 21a:	28 51       	subi	r18, 0x18	; 24
 21c:	42 2f       	mov	r20, r18
 21e:	50 e0       	ldi	r21, 0x00	; 0
 220:	21 e0       	ldi	r18, 0x01	; 1
 222:	30 e0       	ldi	r19, 0x00	; 0
 224:	02 c0       	rjmp	.+4      	; 0x22a <DIO_WritePin+0x198>
 226:	22 0f       	add	r18, r18
 228:	33 1f       	adc	r19, r19
 22a:	4a 95       	dec	r20
 22c:	e2 f7       	brpl	.-8      	; 0x226 <DIO_WritePin+0x194>
 22e:	26 2b       	or	r18, r22
 230:	fc 01       	movw	r30, r24
 232:	20 83       	st	Z, r18
 234:	00 c0       	rjmp	.+0      	; 0x236 <DIO_WritePin+0x1a4>
 236:	00 00       	nop
 238:	0f 90       	pop	r0
 23a:	0f 90       	pop	r0
 23c:	df 91       	pop	r29
 23e:	cf 91       	pop	r28
 240:	08 95       	ret

00000242 <DIO_SetPinDirection>:
 242:	cf 93       	push	r28
 244:	df 93       	push	r29
 246:	00 d0       	rcall	.+0      	; 0x248 <DIO_SetPinDirection+0x6>
 248:	cd b7       	in	r28, 0x3d	; 61
 24a:	de b7       	in	r29, 0x3e	; 62
 24c:	89 83       	std	Y+1, r24	; 0x01
 24e:	6a 83       	std	Y+2, r22	; 0x02
 250:	89 81       	ldd	r24, Y+1	; 0x01
 252:	88 30       	cpi	r24, 0x08	; 8
 254:	60 f5       	brcc	.+88     	; 0x2ae <DIO_SetPinDirection+0x6c>
 256:	8a 81       	ldd	r24, Y+2	; 0x02
 258:	88 23       	and	r24, r24
 25a:	a9 f4       	brne	.+42     	; 0x286 <DIO_SetPinDirection+0x44>
 25c:	8a e3       	ldi	r24, 0x3A	; 58
 25e:	90 e0       	ldi	r25, 0x00	; 0
 260:	2a e3       	ldi	r18, 0x3A	; 58
 262:	30 e0       	ldi	r19, 0x00	; 0
 264:	f9 01       	movw	r30, r18
 266:	60 81       	ld	r22, Z
 268:	29 81       	ldd	r18, Y+1	; 0x01
 26a:	42 2f       	mov	r20, r18
 26c:	50 e0       	ldi	r21, 0x00	; 0
 26e:	21 e0       	ldi	r18, 0x01	; 1
 270:	30 e0       	ldi	r19, 0x00	; 0
 272:	02 c0       	rjmp	.+4      	; 0x278 <DIO_SetPinDirection+0x36>
 274:	22 0f       	add	r18, r18
 276:	33 1f       	adc	r19, r19
 278:	4a 95       	dec	r20
 27a:	e2 f7       	brpl	.-8      	; 0x274 <DIO_SetPinDirection+0x32>
 27c:	20 95       	com	r18
 27e:	26 23       	and	r18, r22
 280:	fc 01       	movw	r30, r24
 282:	20 83       	st	Z, r18
 284:	b0 c0       	rjmp	.+352    	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 286:	8a e3       	ldi	r24, 0x3A	; 58
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	2a e3       	ldi	r18, 0x3A	; 58
 28c:	30 e0       	ldi	r19, 0x00	; 0
 28e:	f9 01       	movw	r30, r18
 290:	60 81       	ld	r22, Z
 292:	29 81       	ldd	r18, Y+1	; 0x01
 294:	42 2f       	mov	r20, r18
 296:	50 e0       	ldi	r21, 0x00	; 0
 298:	21 e0       	ldi	r18, 0x01	; 1
 29a:	30 e0       	ldi	r19, 0x00	; 0
 29c:	02 c0       	rjmp	.+4      	; 0x2a2 <DIO_SetPinDirection+0x60>
 29e:	22 0f       	add	r18, r18
 2a0:	33 1f       	adc	r19, r19
 2a2:	4a 95       	dec	r20
 2a4:	e2 f7       	brpl	.-8      	; 0x29e <DIO_SetPinDirection+0x5c>
 2a6:	26 2b       	or	r18, r22
 2a8:	fc 01       	movw	r30, r24
 2aa:	20 83       	st	Z, r18
 2ac:	9c c0       	rjmp	.+312    	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 2ae:	89 81       	ldd	r24, Y+1	; 0x01
 2b0:	88 30       	cpi	r24, 0x08	; 8
 2b2:	88 f1       	brcs	.+98     	; 0x316 <DIO_SetPinDirection+0xd4>
 2b4:	89 81       	ldd	r24, Y+1	; 0x01
 2b6:	80 31       	cpi	r24, 0x10	; 16
 2b8:	70 f5       	brcc	.+92     	; 0x316 <DIO_SetPinDirection+0xd4>
 2ba:	8a 81       	ldd	r24, Y+2	; 0x02
 2bc:	88 23       	and	r24, r24
 2be:	b1 f4       	brne	.+44     	; 0x2ec <DIO_SetPinDirection+0xaa>
 2c0:	87 e3       	ldi	r24, 0x37	; 55
 2c2:	90 e0       	ldi	r25, 0x00	; 0
 2c4:	27 e3       	ldi	r18, 0x37	; 55
 2c6:	30 e0       	ldi	r19, 0x00	; 0
 2c8:	f9 01       	movw	r30, r18
 2ca:	60 81       	ld	r22, Z
 2cc:	29 81       	ldd	r18, Y+1	; 0x01
 2ce:	28 50       	subi	r18, 0x08	; 8
 2d0:	42 2f       	mov	r20, r18
 2d2:	50 e0       	ldi	r21, 0x00	; 0
 2d4:	21 e0       	ldi	r18, 0x01	; 1
 2d6:	30 e0       	ldi	r19, 0x00	; 0
 2d8:	02 c0       	rjmp	.+4      	; 0x2de <DIO_SetPinDirection+0x9c>
 2da:	22 0f       	add	r18, r18
 2dc:	33 1f       	adc	r19, r19
 2de:	4a 95       	dec	r20
 2e0:	e2 f7       	brpl	.-8      	; 0x2da <DIO_SetPinDirection+0x98>
 2e2:	20 95       	com	r18
 2e4:	26 23       	and	r18, r22
 2e6:	fc 01       	movw	r30, r24
 2e8:	20 83       	st	Z, r18
 2ea:	7d c0       	rjmp	.+250    	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 2ec:	87 e3       	ldi	r24, 0x37	; 55
 2ee:	90 e0       	ldi	r25, 0x00	; 0
 2f0:	27 e3       	ldi	r18, 0x37	; 55
 2f2:	30 e0       	ldi	r19, 0x00	; 0
 2f4:	f9 01       	movw	r30, r18
 2f6:	60 81       	ld	r22, Z
 2f8:	29 81       	ldd	r18, Y+1	; 0x01
 2fa:	28 50       	subi	r18, 0x08	; 8
 2fc:	42 2f       	mov	r20, r18
 2fe:	50 e0       	ldi	r21, 0x00	; 0
 300:	21 e0       	ldi	r18, 0x01	; 1
 302:	30 e0       	ldi	r19, 0x00	; 0
 304:	02 c0       	rjmp	.+4      	; 0x30a <DIO_SetPinDirection+0xc8>
 306:	22 0f       	add	r18, r18
 308:	33 1f       	adc	r19, r19
 30a:	4a 95       	dec	r20
 30c:	e2 f7       	brpl	.-8      	; 0x306 <DIO_SetPinDirection+0xc4>
 30e:	26 2b       	or	r18, r22
 310:	fc 01       	movw	r30, r24
 312:	20 83       	st	Z, r18
 314:	68 c0       	rjmp	.+208    	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 316:	89 81       	ldd	r24, Y+1	; 0x01
 318:	80 31       	cpi	r24, 0x10	; 16
 31a:	88 f1       	brcs	.+98     	; 0x37e <DIO_SetPinDirection+0x13c>
 31c:	89 81       	ldd	r24, Y+1	; 0x01
 31e:	88 31       	cpi	r24, 0x18	; 24
 320:	70 f5       	brcc	.+92     	; 0x37e <DIO_SetPinDirection+0x13c>
 322:	8a 81       	ldd	r24, Y+2	; 0x02
 324:	88 23       	and	r24, r24
 326:	b1 f4       	brne	.+44     	; 0x354 <DIO_SetPinDirection+0x112>
 328:	84 e3       	ldi	r24, 0x34	; 52
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	24 e3       	ldi	r18, 0x34	; 52
 32e:	30 e0       	ldi	r19, 0x00	; 0
 330:	f9 01       	movw	r30, r18
 332:	60 81       	ld	r22, Z
 334:	29 81       	ldd	r18, Y+1	; 0x01
 336:	20 51       	subi	r18, 0x10	; 16
 338:	42 2f       	mov	r20, r18
 33a:	50 e0       	ldi	r21, 0x00	; 0
 33c:	21 e0       	ldi	r18, 0x01	; 1
 33e:	30 e0       	ldi	r19, 0x00	; 0
 340:	02 c0       	rjmp	.+4      	; 0x346 <DIO_SetPinDirection+0x104>
 342:	22 0f       	add	r18, r18
 344:	33 1f       	adc	r19, r19
 346:	4a 95       	dec	r20
 348:	e2 f7       	brpl	.-8      	; 0x342 <DIO_SetPinDirection+0x100>
 34a:	20 95       	com	r18
 34c:	26 23       	and	r18, r22
 34e:	fc 01       	movw	r30, r24
 350:	20 83       	st	Z, r18
 352:	49 c0       	rjmp	.+146    	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 354:	84 e3       	ldi	r24, 0x34	; 52
 356:	90 e0       	ldi	r25, 0x00	; 0
 358:	24 e3       	ldi	r18, 0x34	; 52
 35a:	30 e0       	ldi	r19, 0x00	; 0
 35c:	f9 01       	movw	r30, r18
 35e:	60 81       	ld	r22, Z
 360:	29 81       	ldd	r18, Y+1	; 0x01
 362:	20 51       	subi	r18, 0x10	; 16
 364:	42 2f       	mov	r20, r18
 366:	50 e0       	ldi	r21, 0x00	; 0
 368:	21 e0       	ldi	r18, 0x01	; 1
 36a:	30 e0       	ldi	r19, 0x00	; 0
 36c:	02 c0       	rjmp	.+4      	; 0x372 <DIO_SetPinDirection+0x130>
 36e:	22 0f       	add	r18, r18
 370:	33 1f       	adc	r19, r19
 372:	4a 95       	dec	r20
 374:	e2 f7       	brpl	.-8      	; 0x36e <DIO_SetPinDirection+0x12c>
 376:	26 2b       	or	r18, r22
 378:	fc 01       	movw	r30, r24
 37a:	20 83       	st	Z, r18
 37c:	34 c0       	rjmp	.+104    	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 37e:	89 81       	ldd	r24, Y+1	; 0x01
 380:	88 31       	cpi	r24, 0x18	; 24
 382:	88 f1       	brcs	.+98     	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 384:	89 81       	ldd	r24, Y+1	; 0x01
 386:	80 32       	cpi	r24, 0x20	; 32
 388:	70 f5       	brcc	.+92     	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 38a:	8a 81       	ldd	r24, Y+2	; 0x02
 38c:	88 23       	and	r24, r24
 38e:	b1 f4       	brne	.+44     	; 0x3bc <DIO_SetPinDirection+0x17a>
 390:	81 e3       	ldi	r24, 0x31	; 49
 392:	90 e0       	ldi	r25, 0x00	; 0
 394:	21 e3       	ldi	r18, 0x31	; 49
 396:	30 e0       	ldi	r19, 0x00	; 0
 398:	f9 01       	movw	r30, r18
 39a:	60 81       	ld	r22, Z
 39c:	29 81       	ldd	r18, Y+1	; 0x01
 39e:	28 51       	subi	r18, 0x18	; 24
 3a0:	42 2f       	mov	r20, r18
 3a2:	50 e0       	ldi	r21, 0x00	; 0
 3a4:	21 e0       	ldi	r18, 0x01	; 1
 3a6:	30 e0       	ldi	r19, 0x00	; 0
 3a8:	02 c0       	rjmp	.+4      	; 0x3ae <DIO_SetPinDirection+0x16c>
 3aa:	22 0f       	add	r18, r18
 3ac:	33 1f       	adc	r19, r19
 3ae:	4a 95       	dec	r20
 3b0:	e2 f7       	brpl	.-8      	; 0x3aa <DIO_SetPinDirection+0x168>
 3b2:	20 95       	com	r18
 3b4:	26 23       	and	r18, r22
 3b6:	fc 01       	movw	r30, r24
 3b8:	20 83       	st	Z, r18
 3ba:	15 c0       	rjmp	.+42     	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 3bc:	81 e3       	ldi	r24, 0x31	; 49
 3be:	90 e0       	ldi	r25, 0x00	; 0
 3c0:	21 e3       	ldi	r18, 0x31	; 49
 3c2:	30 e0       	ldi	r19, 0x00	; 0
 3c4:	f9 01       	movw	r30, r18
 3c6:	60 81       	ld	r22, Z
 3c8:	29 81       	ldd	r18, Y+1	; 0x01
 3ca:	28 51       	subi	r18, 0x18	; 24
 3cc:	42 2f       	mov	r20, r18
 3ce:	50 e0       	ldi	r21, 0x00	; 0
 3d0:	21 e0       	ldi	r18, 0x01	; 1
 3d2:	30 e0       	ldi	r19, 0x00	; 0
 3d4:	02 c0       	rjmp	.+4      	; 0x3da <DIO_SetPinDirection+0x198>
 3d6:	22 0f       	add	r18, r18
 3d8:	33 1f       	adc	r19, r19
 3da:	4a 95       	dec	r20
 3dc:	e2 f7       	brpl	.-8      	; 0x3d6 <DIO_SetPinDirection+0x194>
 3de:	26 2b       	or	r18, r22
 3e0:	fc 01       	movw	r30, r24
 3e2:	20 83       	st	Z, r18
 3e4:	00 c0       	rjmp	.+0      	; 0x3e6 <DIO_SetPinDirection+0x1a4>
 3e6:	00 00       	nop
 3e8:	0f 90       	pop	r0
 3ea:	0f 90       	pop	r0
 3ec:	df 91       	pop	r29
 3ee:	cf 91       	pop	r28
 3f0:	08 95       	ret

000003f2 <main>:
#include "includes/BitwiseOperations.h"
#include "includes/Task.h"
#include "includes/schadular.h"

int main(void)
{
 3f2:	cf 93       	push	r28
 3f4:	df 93       	push	r29
 3f6:	cd b7       	in	r28, 0x3d	; 61
 3f8:	de b7       	in	r29, 0x3e	; 62
 3fa:	65 97       	sbiw	r28, 0x15	; 21
 3fc:	0f b6       	in	r0, 0x3f	; 63
 3fe:	f8 94       	cli
 400:	de bf       	out	0x3e, r29	; 62
 402:	0f be       	out	0x3f, r0	; 63
 404:	cd bf       	out	0x3d, r28	; 61
	
    timer0_init_CTC_mode;            /*Timer compare mode initialization */
    DIO_SetPinDirection(LED1,OUTPUT); /*Set DDRB5 (LED1) Output*/
 406:	61 e0       	ldi	r22, 0x01	; 1
 408:	8d e0       	ldi	r24, 0x0D	; 13
 40a:	0e 94 21 01 	call	0x242	; 0x242 <DIO_SetPinDirection>
    DIO_SetPinDirection(LED2,OUTPUT); /*Set DDRB6 (LED2) Output*/
 40e:	61 e0       	ldi	r22, 0x01	; 1
 410:	8e e0       	ldi	r24, 0x0E	; 14
 412:	0e 94 21 01 	call	0x242	; 0x242 <DIO_SetPinDirection>
    DIO_SetPinDirection(LED3,OUTPUT); /*Set DDRB7 (LED3) Output*/
 416:	61 e0       	ldi	r22, 0x01	; 1
 418:	8f e0       	ldi	r24, 0x0F	; 15
 41a:	0e 94 21 01 	call	0x242	; 0x242 <DIO_SetPinDirection>
	
	/*temporary structure to assign them inside the add fun in each element of array of structure */
    Task task1; /*GO*/
	task1.ptr_func=GO;
 41e:	8d e3       	ldi	r24, 0x3D	; 61
 420:	95 e0       	ldi	r25, 0x05	; 5
 422:	9a 83       	std	Y+2, r25	; 0x02
 424:	89 83       	std	Y+1, r24	; 0x01
	task1.Task_Periodicity=ONE_SECOUND;
 426:	88 ee       	ldi	r24, 0xE8	; 232
 428:	93 e0       	ldi	r25, 0x03	; 3
 42a:	9c 83       	std	Y+4, r25	; 0x04
 42c:	8b 83       	std	Y+3, r24	; 0x03
	task1.Remaining_Ticks=ONE_SECOUND;
 42e:	88 ee       	ldi	r24, 0xE8	; 232
 430:	93 e0       	ldi	r25, 0x03	; 3
 432:	9e 83       	std	Y+6, r25	; 0x06
 434:	8d 83       	std	Y+5, r24	; 0x05
	task1.priority=THIRD;
 436:	83 e0       	ldi	r24, 0x03	; 3
 438:	8f 83       	std	Y+7, r24	; 0x07
	
	
	/*temporary structure to assign them inside the add fun in each element of array of structure */
	Task task2;/*STOP*/
	task2.ptr_func=STOP;
 43a:	81 e5       	ldi	r24, 0x51	; 81
 43c:	95 e0       	ldi	r25, 0x05	; 5
 43e:	99 87       	std	Y+9, r25	; 0x09
 440:	88 87       	std	Y+8, r24	; 0x08
	task2.Task_Periodicity=TWO_SECOND;
 442:	80 ed       	ldi	r24, 0xD0	; 208
 444:	97 e0       	ldi	r25, 0x07	; 7
 446:	9b 87       	std	Y+11, r25	; 0x0b
 448:	8a 87       	std	Y+10, r24	; 0x0a
	task2.Remaining_Ticks=TWO_SECOND; 
 44a:	80 ed       	ldi	r24, 0xD0	; 208
 44c:	97 e0       	ldi	r25, 0x07	; 7
 44e:	9d 87       	std	Y+13, r25	; 0x0d
 450:	8c 87       	std	Y+12, r24	; 0x0c
	task2.priority=FIRST;
 452:	81 e0       	ldi	r24, 0x01	; 1
 454:	8e 87       	std	Y+14, r24	; 0x0e
	
	 /*temporary structure to assign them inside the add fun in each element of array of structure */
    Task task3;/*READY*/
    task3.ptr_func=READY;
 456:	85 e6       	ldi	r24, 0x65	; 101
 458:	95 e0       	ldi	r25, 0x05	; 5
 45a:	98 8b       	std	Y+16, r25	; 0x10
 45c:	8f 87       	std	Y+15, r24	; 0x0f
	task3.Task_Periodicity=THREE_SECOUND;
 45e:	88 eb       	ldi	r24, 0xB8	; 184
 460:	9b e0       	ldi	r25, 0x0B	; 11
 462:	9a 8b       	std	Y+18, r25	; 0x12
 464:	89 8b       	std	Y+17, r24	; 0x11
	task3.Remaining_Ticks=THREE_SECOUND;
 466:	88 eb       	ldi	r24, 0xB8	; 184
 468:	9b e0       	ldi	r25, 0x0B	; 11
 46a:	9c 8b       	std	Y+20, r25	; 0x14
 46c:	8b 8b       	std	Y+19, r24	; 0x13
    task3.priority=SECOND;
 46e:	82 e0       	ldi	r24, 0x02	; 2
 470:	8d 8b       	std	Y+21, r24	; 0x15
	
	 /*call add task function that take structure and we assign the elements of each structure */
	scheduler_Add_Task(&task1);/* send the address of structure task1 to add function */
 472:	ce 01       	movw	r24, r28
 474:	01 96       	adiw	r24, 0x01	; 1
 476:	0e 94 02 03 	call	0x604	; 0x604 <scheduler_Add_Task>
	scheduler_Add_Task(&task2);/* send the address of structure task2 to add function */
 47a:	ce 01       	movw	r24, r28
 47c:	08 96       	adiw	r24, 0x08	; 8
 47e:	0e 94 02 03 	call	0x604	; 0x604 <scheduler_Add_Task>
	scheduler_Add_Task(&task3);/* send the address of structure task3 to add function */
 482:	ce 01       	movw	r24, r28
 484:	0f 96       	adiw	r24, 0x0f	; 15
 486:	0e 94 02 03 	call	0x604	; 0x604 <scheduler_Add_Task>
	schadular_init_start();/*initialize the scheduler */
 48a:	0e 94 5d 02 	call	0x4ba	; 0x4ba <schadular_init_start>
 48e:	80 e0       	ldi	r24, 0x00	; 0
 490:	90 e0       	ldi	r25, 0x00	; 0
    
}
 492:	65 96       	adiw	r28, 0x15	; 21
 494:	0f b6       	in	r0, 0x3f	; 63
 496:	f8 94       	cli
 498:	de bf       	out	0x3e, r29	; 62
 49a:	0f be       	out	0x3f, r0	; 63
 49c:	cd bf       	out	0x3d, r28	; 61
 49e:	df 91       	pop	r29
 4a0:	cf 91       	pop	r28
 4a2:	08 95       	ret

000004a4 <SET_FLAG>:
/* I/p : N/A */
/* O/p : N/A */
/* Return : void */
/* Function that SET FLAG BY CALL THIS FUN INSIDE ISR */
void SET_FLAG()
{
 4a4:	cf 93       	push	r28
 4a6:	df 93       	push	r29
 4a8:	cd b7       	in	r28, 0x3d	; 61
 4aa:	de b7       	in	r29, 0x3e	; 62
	FLAG = ONE ;/*flag is set when compare match occur in ISA */
 4ac:	81 e0       	ldi	r24, 0x01	; 1
 4ae:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_end>
}
 4b2:	00 00       	nop
 4b4:	df 91       	pop	r29
 4b6:	cf 91       	pop	r28
 4b8:	08 95       	ret

000004ba <schadular_init_start>:
/* I/p : N/A */
/* O/p : N/A */
/* Return : void */
/* Function that initialize the scheduler  */
void schadular_init_start()
{
 4ba:	cf 93       	push	r28
 4bc:	df 93       	push	r29
 4be:	cd b7       	in	r28, 0x3d	; 61
 4c0:	de b7       	in	r29, 0x3e	; 62
	timer0_init_CTC_mode();/*TIMER INIT */
 4c2:	0e 94 bd 05 	call	0xb7a	; 0xb7a <timer0_init_CTC_mode>
	set_call_back(SET_FLAG);/*CALL BACK FUN THAT TAKES THE ADDRESS OFN SET FLAG FUN TO SET THIS FLAG EACH COMPARE */
 4c6:	82 e5       	ldi	r24, 0x52	; 82
 4c8:	92 e0       	ldi	r25, 0x02	; 2
 4ca:	0e 94 aa 05 	call	0xb54	; 0xb54 <set_call_back>
	sort_task();
 4ce:	0e 94 a5 03 	call	0x74a	; 0x74a <sort_task>
	Remove(GO);
 4d2:	8d e3       	ldi	r24, 0x3D	; 61
 4d4:	95 e0       	ldi	r25, 0x05	; 5
 4d6:	0e 94 40 04 	call	0x880	; 0x880 <Remove>
	fun as argument and receive it in remove fun in pointer to fun 
	to access the structure element by compare the address */
	while(ONE)
	{
		
		if(ONE == FLAG)/*check if flag is set and its set every compare occur and its set inside ISR */
 4da:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_end>
 4de:	81 30       	cpi	r24, 0x01	; 1
 4e0:	e1 f7       	brne	.-8      	; 0x4da <schadular_init_start+0x20>
		{
			 FLAG=ZERO;
 4e2:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__data_end>
			 prefield();/*call algorithm for scheduling */
 4e6:	0e 94 76 02 	call	0x4ec	; 0x4ec <prefield>

		}
	}	
 4ea:	f7 cf       	rjmp	.-18     	; 0x4da <schadular_init_start+0x20>

000004ec <prefield>:
/* I/p : array of pointer to function that void/void  and size of array*/
/* O/p : N/A */
/* Return : void */
/* Function that takes array of pointer to fun to access the task  */
static void prefield()
{
 4ec:	cf 93       	push	r28
 4ee:	df 93       	push	r29
 4f0:	1f 92       	push	r1
 4f2:	cd b7       	in	r28, 0x3d	; 61
 4f4:	de b7       	in	r29, 0x3e	; 62
	uint8 i;/*INDEX */
	for(i=ZERO ; i<index ; i++)
 4f6:	19 82       	std	Y+1, r1	; 0x01
 4f8:	6d c0       	rjmp	.+218    	; 0x5d4 <prefield+0xe8>
	{
		/* the idea of this algorithm is in the beginning the periodicity equal time remain 
		so to make sure to execute this task is wait untiles periodicity equal zero so the task execute and 
		initialize the periodicty == remaining and loop like this again this algorithm make sure that each task will be
		executed in its periodicity */
      Task_Arr[i].Remaining_Ticks--;
 4fa:	89 81       	ldd	r24, Y+1	; 0x01
 4fc:	28 2f       	mov	r18, r24
 4fe:	30 e0       	ldi	r19, 0x00	; 0
 500:	c9 01       	movw	r24, r18
 502:	88 0f       	add	r24, r24
 504:	99 1f       	adc	r25, r25
 506:	88 0f       	add	r24, r24
 508:	99 1f       	adc	r25, r25
 50a:	88 0f       	add	r24, r24
 50c:	99 1f       	adc	r25, r25
 50e:	82 1b       	sub	r24, r18
 510:	93 0b       	sbc	r25, r19
 512:	87 59       	subi	r24, 0x97	; 151
 514:	9f 4f       	sbci	r25, 0xFF	; 255
 516:	fc 01       	movw	r30, r24
 518:	80 81       	ld	r24, Z
 51a:	91 81       	ldd	r25, Z+1	; 0x01
 51c:	ac 01       	movw	r20, r24
 51e:	41 50       	subi	r20, 0x01	; 1
 520:	51 09       	sbc	r21, r1
 522:	c9 01       	movw	r24, r18
 524:	88 0f       	add	r24, r24
 526:	99 1f       	adc	r25, r25
 528:	88 0f       	add	r24, r24
 52a:	99 1f       	adc	r25, r25
 52c:	88 0f       	add	r24, r24
 52e:	99 1f       	adc	r25, r25
 530:	82 1b       	sub	r24, r18
 532:	93 0b       	sbc	r25, r19
 534:	87 59       	subi	r24, 0x97	; 151
 536:	9f 4f       	sbci	r25, 0xFF	; 255
 538:	fc 01       	movw	r30, r24
 53a:	51 83       	std	Z+1, r21	; 0x01
 53c:	40 83       	st	Z, r20
	  /*when remain = zero it means periodicity ticks finished and its time to execute task */
	  if(Task_Arr[i].Remaining_Ticks==ZERO)
 53e:	89 81       	ldd	r24, Y+1	; 0x01
 540:	28 2f       	mov	r18, r24
 542:	30 e0       	ldi	r19, 0x00	; 0
 544:	c9 01       	movw	r24, r18
 546:	88 0f       	add	r24, r24
 548:	99 1f       	adc	r25, r25
 54a:	88 0f       	add	r24, r24
 54c:	99 1f       	adc	r25, r25
 54e:	88 0f       	add	r24, r24
 550:	99 1f       	adc	r25, r25
 552:	82 1b       	sub	r24, r18
 554:	93 0b       	sbc	r25, r19
 556:	87 59       	subi	r24, 0x97	; 151
 558:	9f 4f       	sbci	r25, 0xFF	; 255
 55a:	fc 01       	movw	r30, r24
 55c:	80 81       	ld	r24, Z
 55e:	91 81       	ldd	r25, Z+1	; 0x01
 560:	89 2b       	or	r24, r25
 562:	a9 f5       	brne	.+106    	; 0x5ce <prefield+0xe2>
	  {
		  Task_Arr[i].ptr_func();
 564:	89 81       	ldd	r24, Y+1	; 0x01
 566:	28 2f       	mov	r18, r24
 568:	30 e0       	ldi	r19, 0x00	; 0
 56a:	c9 01       	movw	r24, r18
 56c:	88 0f       	add	r24, r24
 56e:	99 1f       	adc	r25, r25
 570:	88 0f       	add	r24, r24
 572:	99 1f       	adc	r25, r25
 574:	88 0f       	add	r24, r24
 576:	99 1f       	adc	r25, r25
 578:	82 1b       	sub	r24, r18
 57a:	93 0b       	sbc	r25, r19
 57c:	8b 59       	subi	r24, 0x9B	; 155
 57e:	9f 4f       	sbci	r25, 0xFF	; 255
 580:	fc 01       	movw	r30, r24
 582:	80 81       	ld	r24, Z
 584:	91 81       	ldd	r25, Z+1	; 0x01
 586:	fc 01       	movw	r30, r24
 588:	09 95       	icall
		  Task_Arr[i].Remaining_Ticks=Task_Arr[i].Task_Periodicity;
 58a:	89 81       	ldd	r24, Y+1	; 0x01
 58c:	28 2f       	mov	r18, r24
 58e:	30 e0       	ldi	r19, 0x00	; 0
 590:	89 81       	ldd	r24, Y+1	; 0x01
 592:	48 2f       	mov	r20, r24
 594:	50 e0       	ldi	r21, 0x00	; 0
 596:	ca 01       	movw	r24, r20
 598:	88 0f       	add	r24, r24
 59a:	99 1f       	adc	r25, r25
 59c:	88 0f       	add	r24, r24
 59e:	99 1f       	adc	r25, r25
 5a0:	88 0f       	add	r24, r24
 5a2:	99 1f       	adc	r25, r25
 5a4:	84 1b       	sub	r24, r20
 5a6:	95 0b       	sbc	r25, r21
 5a8:	89 59       	subi	r24, 0x99	; 153
 5aa:	9f 4f       	sbci	r25, 0xFF	; 255
 5ac:	fc 01       	movw	r30, r24
 5ae:	40 81       	ld	r20, Z
 5b0:	51 81       	ldd	r21, Z+1	; 0x01
 5b2:	c9 01       	movw	r24, r18
 5b4:	88 0f       	add	r24, r24
 5b6:	99 1f       	adc	r25, r25
 5b8:	88 0f       	add	r24, r24
 5ba:	99 1f       	adc	r25, r25
 5bc:	88 0f       	add	r24, r24
 5be:	99 1f       	adc	r25, r25
 5c0:	82 1b       	sub	r24, r18
 5c2:	93 0b       	sbc	r25, r19
 5c4:	87 59       	subi	r24, 0x97	; 151
 5c6:	9f 4f       	sbci	r25, 0xFF	; 255
 5c8:	fc 01       	movw	r30, r24
 5ca:	51 83       	std	Z+1, r21	; 0x01
 5cc:	40 83       	st	Z, r20
/* Return : void */
/* Function that takes array of pointer to fun to access the task  */
static void prefield()
{
	uint8 i;/*INDEX */
	for(i=ZERO ; i<index ; i++)
 5ce:	89 81       	ldd	r24, Y+1	; 0x01
 5d0:	8f 5f       	subi	r24, 0xFF	; 255
 5d2:	89 83       	std	Y+1, r24	; 0x01
 5d4:	89 81       	ldd	r24, Y+1	; 0x01
 5d6:	28 2f       	mov	r18, r24
 5d8:	30 e0       	ldi	r19, 0x00	; 0
 5da:	40 e0       	ldi	r20, 0x00	; 0
 5dc:	50 e0       	ldi	r21, 0x00	; 0
 5de:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 5e2:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 5e6:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 5ea:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 5ee:	28 17       	cp	r18, r24
 5f0:	39 07       	cpc	r19, r25
 5f2:	4a 07       	cpc	r20, r26
 5f4:	5b 07       	cpc	r21, r27
 5f6:	08 f4       	brcc	.+2      	; 0x5fa <prefield+0x10e>
 5f8:	80 cf       	rjmp	.-256    	; 0x4fa <prefield+0xe>
		  Task_Arr[i].ptr_func();
		  Task_Arr[i].Remaining_Ticks=Task_Arr[i].Task_Periodicity;
		  
	  }
	}
}
 5fa:	00 00       	nop
 5fc:	0f 90       	pop	r0
 5fe:	df 91       	pop	r29
 600:	cf 91       	pop	r28
 602:	08 95       	ret

00000604 <scheduler_Add_Task>:
/* I/p : array of pointer to function that void/void  and size of array*/
/* O/p : N/A */
/* Return : void */
/* Function that takes array of pointer to fun to access the task  */
uint8 scheduler_Add_Task(Task *ptr)/*the argument for add fun is structure so i receive it in pointer to structure */
{
 604:	cf 93       	push	r28
 606:	df 93       	push	r29
 608:	00 d0       	rcall	.+0      	; 0x60a <scheduler_Add_Task+0x6>
 60a:	1f 92       	push	r1
 60c:	cd b7       	in	r28, 0x3d	; 61
 60e:	de b7       	in	r29, 0x3e	; 62
 610:	9b 83       	std	Y+3, r25	; 0x03
 612:	8a 83       	std	Y+2, r24	; 0x02
		uint8 x = ONE;
 614:	81 e0       	ldi	r24, 0x01	; 1
 616:	89 83       	std	Y+1, r24	; 0x01
		
		if (index < NUMBER_OF_TASK)
 618:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 61c:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 620:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 624:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 628:	03 97       	sbiw	r24, 0x03	; 3
 62a:	a1 05       	cpc	r26, r1
 62c:	b1 05       	cpc	r27, r1
 62e:	08 f0       	brcs	.+2      	; 0x632 <scheduler_Add_Task+0x2e>
 630:	84 c0       	rjmp	.+264    	; 0x73a <scheduler_Add_Task+0x136>
		{
			/* here i am initialize the structure element so in the main i 
			send this structure as argument and here aim assign  each element*/
			
			Task_Arr[index].ptr_func=ptr->ptr_func;/*assign the value of ptr_fun element in Task_array = ptr in main */
 632:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 636:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 63a:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 63e:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 642:	2a 81       	ldd	r18, Y+2	; 0x02
 644:	3b 81       	ldd	r19, Y+3	; 0x03
 646:	f9 01       	movw	r30, r18
 648:	20 81       	ld	r18, Z
 64a:	31 81       	ldd	r19, Z+1	; 0x01
 64c:	ac 01       	movw	r20, r24
 64e:	ca 01       	movw	r24, r20
 650:	88 0f       	add	r24, r24
 652:	99 1f       	adc	r25, r25
 654:	88 0f       	add	r24, r24
 656:	99 1f       	adc	r25, r25
 658:	88 0f       	add	r24, r24
 65a:	99 1f       	adc	r25, r25
 65c:	84 1b       	sub	r24, r20
 65e:	95 0b       	sbc	r25, r21
 660:	8b 59       	subi	r24, 0x9B	; 155
 662:	9f 4f       	sbci	r25, 0xFF	; 255
 664:	fc 01       	movw	r30, r24
 666:	31 83       	std	Z+1, r19	; 0x01
 668:	20 83       	st	Z, r18
			Task_Arr[index].Task_Periodicity=ptr->Task_Periodicity;
 66a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 66e:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 672:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 676:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 67a:	2a 81       	ldd	r18, Y+2	; 0x02
 67c:	3b 81       	ldd	r19, Y+3	; 0x03
 67e:	f9 01       	movw	r30, r18
 680:	22 81       	ldd	r18, Z+2	; 0x02
 682:	33 81       	ldd	r19, Z+3	; 0x03
 684:	ac 01       	movw	r20, r24
 686:	ca 01       	movw	r24, r20
 688:	88 0f       	add	r24, r24
 68a:	99 1f       	adc	r25, r25
 68c:	88 0f       	add	r24, r24
 68e:	99 1f       	adc	r25, r25
 690:	88 0f       	add	r24, r24
 692:	99 1f       	adc	r25, r25
 694:	84 1b       	sub	r24, r20
 696:	95 0b       	sbc	r25, r21
 698:	89 59       	subi	r24, 0x99	; 153
 69a:	9f 4f       	sbci	r25, 0xFF	; 255
 69c:	fc 01       	movw	r30, r24
 69e:	31 83       	std	Z+1, r19	; 0x01
 6a0:	20 83       	st	Z, r18
			Task_Arr[index].Remaining_Ticks=ptr->Remaining_Ticks;
 6a2:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 6a6:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 6aa:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 6ae:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 6b2:	2a 81       	ldd	r18, Y+2	; 0x02
 6b4:	3b 81       	ldd	r19, Y+3	; 0x03
 6b6:	f9 01       	movw	r30, r18
 6b8:	24 81       	ldd	r18, Z+4	; 0x04
 6ba:	35 81       	ldd	r19, Z+5	; 0x05
 6bc:	ac 01       	movw	r20, r24
 6be:	ca 01       	movw	r24, r20
 6c0:	88 0f       	add	r24, r24
 6c2:	99 1f       	adc	r25, r25
 6c4:	88 0f       	add	r24, r24
 6c6:	99 1f       	adc	r25, r25
 6c8:	88 0f       	add	r24, r24
 6ca:	99 1f       	adc	r25, r25
 6cc:	84 1b       	sub	r24, r20
 6ce:	95 0b       	sbc	r25, r21
 6d0:	87 59       	subi	r24, 0x97	; 151
 6d2:	9f 4f       	sbci	r25, 0xFF	; 255
 6d4:	fc 01       	movw	r30, r24
 6d6:	31 83       	std	Z+1, r19	; 0x01
 6d8:	20 83       	st	Z, r18
			Task_Arr[index].priority=ptr->priority;
 6da:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 6de:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 6e2:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 6e6:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 6ea:	2a 81       	ldd	r18, Y+2	; 0x02
 6ec:	3b 81       	ldd	r19, Y+3	; 0x03
 6ee:	f9 01       	movw	r30, r18
 6f0:	46 81       	ldd	r20, Z+6	; 0x06
 6f2:	9c 01       	movw	r18, r24
 6f4:	c9 01       	movw	r24, r18
 6f6:	88 0f       	add	r24, r24
 6f8:	99 1f       	adc	r25, r25
 6fa:	88 0f       	add	r24, r24
 6fc:	99 1f       	adc	r25, r25
 6fe:	88 0f       	add	r24, r24
 700:	99 1f       	adc	r25, r25
 702:	82 1b       	sub	r24, r18
 704:	93 0b       	sbc	r25, r19
 706:	85 59       	subi	r24, 0x95	; 149
 708:	9f 4f       	sbci	r25, 0xFF	; 255
 70a:	fc 01       	movw	r30, r24
 70c:	40 83       	st	Z, r20
             /*access each element in structure using arrow cause its pointer */
			index++;
 70e:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 712:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 716:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 71a:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 71e:	01 96       	adiw	r24, 0x01	; 1
 720:	a1 1d       	adc	r26, r1
 722:	b1 1d       	adc	r27, r1
 724:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <index>
 728:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <index+0x1>
 72c:	a0 93 63 00 	sts	0x0063, r26	; 0x800063 <index+0x2>
 730:	b0 93 64 00 	sts	0x0064, r27	; 0x800064 <index+0x3>
			x = ONE;
 734:	81 e0       	ldi	r24, 0x01	; 1
 736:	89 83       	std	Y+1, r24	; 0x01
 738:	01 c0       	rjmp	.+2      	; 0x73c <scheduler_Add_Task+0x138>
		}
		else
		{
			x = ZERO;
 73a:	19 82       	std	Y+1, r1	; 0x01
		}
		return x;	
 73c:	89 81       	ldd	r24, Y+1	; 0x01
}
 73e:	0f 90       	pop	r0
 740:	0f 90       	pop	r0
 742:	0f 90       	pop	r0
 744:	df 91       	pop	r29
 746:	cf 91       	pop	r28
 748:	08 95       	ret

0000074a <sort_task>:
/* O/p : N/A */
/* Return : void */
/*function that takes array of structure and sort these structure 
by priority and the lowest priority is the lowest address and so on   */
static void sort_task()
{
 74a:	cf 93       	push	r28
 74c:	df 93       	push	r29
 74e:	00 d0       	rcall	.+0      	; 0x750 <sort_task+0x6>
 750:	cd b7       	in	r28, 0x3d	; 61
 752:	de b7       	in	r29, 0x3e	; 62
	uint8 i,j;
	for(i=0 ; i<NUMBER_OF_TASK ; ++i)/*loop for sort */
 754:	19 82       	std	Y+1, r1	; 0x01
 756:	50 c0       	rjmp	.+160    	; 0x7f8 <sort_task+0xae>
	{
	for(j=i+1;j<NUMBER_OF_TASK;++j)
 758:	89 81       	ldd	r24, Y+1	; 0x01
 75a:	8f 5f       	subi	r24, 0xFF	; 255
 75c:	8a 83       	std	Y+2, r24	; 0x02
 75e:	45 c0       	rjmp	.+138    	; 0x7ea <sort_task+0xa0>
	{
		if(Task_Arr[i].priority>Task_Arr[j].priority)   /* To sort in descending order, change > to < in this line. */
 760:	89 81       	ldd	r24, Y+1	; 0x01
 762:	28 2f       	mov	r18, r24
 764:	30 e0       	ldi	r19, 0x00	; 0
 766:	c9 01       	movw	r24, r18
 768:	88 0f       	add	r24, r24
 76a:	99 1f       	adc	r25, r25
 76c:	88 0f       	add	r24, r24
 76e:	99 1f       	adc	r25, r25
 770:	88 0f       	add	r24, r24
 772:	99 1f       	adc	r25, r25
 774:	82 1b       	sub	r24, r18
 776:	93 0b       	sbc	r25, r19
 778:	85 59       	subi	r24, 0x95	; 149
 77a:	9f 4f       	sbci	r25, 0xFF	; 255
 77c:	fc 01       	movw	r30, r24
 77e:	40 81       	ld	r20, Z
 780:	8a 81       	ldd	r24, Y+2	; 0x02
 782:	28 2f       	mov	r18, r24
 784:	30 e0       	ldi	r19, 0x00	; 0
 786:	c9 01       	movw	r24, r18
 788:	88 0f       	add	r24, r24
 78a:	99 1f       	adc	r25, r25
 78c:	88 0f       	add	r24, r24
 78e:	99 1f       	adc	r25, r25
 790:	88 0f       	add	r24, r24
 792:	99 1f       	adc	r25, r25
 794:	82 1b       	sub	r24, r18
 796:	93 0b       	sbc	r25, r19
 798:	85 59       	subi	r24, 0x95	; 149
 79a:	9f 4f       	sbci	r25, 0xFF	; 255
 79c:	fc 01       	movw	r30, r24
 79e:	80 81       	ld	r24, Z
 7a0:	84 17       	cp	r24, r20
 7a2:	00 f5       	brcc	.+64     	; 0x7e4 <sort_task+0x9a>
		{
			swap(&Task_Arr[i],&Task_Arr[j]);/* call swap fun and the argument is address for two element in task_arr [i][j]*/
 7a4:	8a 81       	ldd	r24, Y+2	; 0x02
 7a6:	28 2f       	mov	r18, r24
 7a8:	30 e0       	ldi	r19, 0x00	; 0
 7aa:	c9 01       	movw	r24, r18
 7ac:	88 0f       	add	r24, r24
 7ae:	99 1f       	adc	r25, r25
 7b0:	88 0f       	add	r24, r24
 7b2:	99 1f       	adc	r25, r25
 7b4:	88 0f       	add	r24, r24
 7b6:	99 1f       	adc	r25, r25
 7b8:	82 1b       	sub	r24, r18
 7ba:	93 0b       	sbc	r25, r19
 7bc:	ac 01       	movw	r20, r24
 7be:	4b 59       	subi	r20, 0x9B	; 155
 7c0:	5f 4f       	sbci	r21, 0xFF	; 255
 7c2:	89 81       	ldd	r24, Y+1	; 0x01
 7c4:	28 2f       	mov	r18, r24
 7c6:	30 e0       	ldi	r19, 0x00	; 0
 7c8:	c9 01       	movw	r24, r18
 7ca:	88 0f       	add	r24, r24
 7cc:	99 1f       	adc	r25, r25
 7ce:	88 0f       	add	r24, r24
 7d0:	99 1f       	adc	r25, r25
 7d2:	88 0f       	add	r24, r24
 7d4:	99 1f       	adc	r25, r25
 7d6:	82 1b       	sub	r24, r18
 7d8:	93 0b       	sbc	r25, r19
 7da:	8b 59       	subi	r24, 0x9B	; 155
 7dc:	9f 4f       	sbci	r25, 0xFF	; 255
 7de:	ba 01       	movw	r22, r20
 7e0:	0e 94 06 04 	call	0x80c	; 0x80c <swap>
static void sort_task()
{
	uint8 i,j;
	for(i=0 ; i<NUMBER_OF_TASK ; ++i)/*loop for sort */
	{
	for(j=i+1;j<NUMBER_OF_TASK;++j)
 7e4:	8a 81       	ldd	r24, Y+2	; 0x02
 7e6:	8f 5f       	subi	r24, 0xFF	; 255
 7e8:	8a 83       	std	Y+2, r24	; 0x02
 7ea:	8a 81       	ldd	r24, Y+2	; 0x02
 7ec:	83 30       	cpi	r24, 0x03	; 3
 7ee:	08 f4       	brcc	.+2      	; 0x7f2 <sort_task+0xa8>
 7f0:	b7 cf       	rjmp	.-146    	; 0x760 <sort_task+0x16>
/*function that takes array of structure and sort these structure 
by priority and the lowest priority is the lowest address and so on   */
static void sort_task()
{
	uint8 i,j;
	for(i=0 ; i<NUMBER_OF_TASK ; ++i)/*loop for sort */
 7f2:	89 81       	ldd	r24, Y+1	; 0x01
 7f4:	8f 5f       	subi	r24, 0xFF	; 255
 7f6:	89 83       	std	Y+1, r24	; 0x01
 7f8:	89 81       	ldd	r24, Y+1	; 0x01
 7fa:	83 30       	cpi	r24, 0x03	; 3
 7fc:	08 f4       	brcc	.+2      	; 0x800 <sort_task+0xb6>
 7fe:	ac cf       	rjmp	.-168    	; 0x758 <sort_task+0xe>
			swap(&Task_Arr[i],&Task_Arr[j]);/* call swap fun and the argument is address for two element in task_arr [i][j]*/
		}
	}
	}
	
}
 800:	00 00       	nop
 802:	0f 90       	pop	r0
 804:	0f 90       	pop	r0
 806:	df 91       	pop	r29
 808:	cf 91       	pop	r28
 80a:	08 95       	ret

0000080c <swap>:
/* O/p : N/A */
/* Return : void */
/* Function that takes two pointer to structure that carry address of two structure inside array 
of pointer to structure call task_arr that send from sort fun  */
static void swap(Task *task1 , Task *task2)
{
 80c:	cf 93       	push	r28
 80e:	df 93       	push	r29
 810:	cd b7       	in	r28, 0x3d	; 61
 812:	de b7       	in	r29, 0x3e	; 62
 814:	2b 97       	sbiw	r28, 0x0b	; 11
 816:	0f b6       	in	r0, 0x3f	; 63
 818:	f8 94       	cli
 81a:	de bf       	out	0x3e, r29	; 62
 81c:	0f be       	out	0x3f, r0	; 63
 81e:	cd bf       	out	0x3d, r28	; 61
 820:	99 87       	std	Y+9, r25	; 0x09
 822:	88 87       	std	Y+8, r24	; 0x08
 824:	7b 87       	std	Y+11, r23	; 0x0b
 826:	6a 87       	std	Y+10, r22	; 0x0a
	/* swap function that task address for structure and receive it in pointer to structure and
     use temp variable from type TASK struct to use it as temporary variable */
	Task temp ;
	/*swap structure task1 with structure task2 by temp */
    temp=*task1;  
 828:	88 85       	ldd	r24, Y+8	; 0x08
 82a:	99 85       	ldd	r25, Y+9	; 0x09
 82c:	27 e0       	ldi	r18, 0x07	; 7
 82e:	fc 01       	movw	r30, r24
 830:	ce 01       	movw	r24, r28
 832:	01 96       	adiw	r24, 0x01	; 1
 834:	dc 01       	movw	r26, r24
 836:	01 90       	ld	r0, Z+
 838:	0d 92       	st	X+, r0
 83a:	2a 95       	dec	r18
 83c:	e1 f7       	brne	.-8      	; 0x836 <swap+0x2a>
	*task1=*task2;
 83e:	88 85       	ldd	r24, Y+8	; 0x08
 840:	99 85       	ldd	r25, Y+9	; 0x09
 842:	2a 85       	ldd	r18, Y+10	; 0x0a
 844:	3b 85       	ldd	r19, Y+11	; 0x0b
 846:	47 e0       	ldi	r20, 0x07	; 7
 848:	f9 01       	movw	r30, r18
 84a:	dc 01       	movw	r26, r24
 84c:	01 90       	ld	r0, Z+
 84e:	0d 92       	st	X+, r0
 850:	4a 95       	dec	r20
 852:	e1 f7       	brne	.-8      	; 0x84c <swap+0x40>
	*task2=temp;	
 854:	8a 85       	ldd	r24, Y+10	; 0x0a
 856:	9b 85       	ldd	r25, Y+11	; 0x0b
 858:	47 e0       	ldi	r20, 0x07	; 7
 85a:	9e 01       	movw	r18, r28
 85c:	2f 5f       	subi	r18, 0xFF	; 255
 85e:	3f 4f       	sbci	r19, 0xFF	; 255
 860:	f9 01       	movw	r30, r18
 862:	dc 01       	movw	r26, r24
 864:	01 90       	ld	r0, Z+
 866:	0d 92       	st	X+, r0
 868:	4a 95       	dec	r20
 86a:	e1 f7       	brne	.-8      	; 0x864 <__stack+0x5>
}
 86c:	00 00       	nop
 86e:	2b 96       	adiw	r28, 0x0b	; 11
 870:	0f b6       	in	r0, 0x3f	; 63
 872:	f8 94       	cli
 874:	de bf       	out	0x3e, r29	; 62
 876:	0f be       	out	0x3f, r0	; 63
 878:	cd bf       	out	0x3d, r28	; 61
 87a:	df 91       	pop	r29
 87c:	cf 91       	pop	r28
 87e:	08 95       	ret

00000880 <Remove>:
/* O/p : N/A */
/* Return : void */
/* function takes pointer to fun for the removed element in array of structure and i receive the address of fun and store it in pointer to fun 
to use this to detect the index of the removed element   */
void Remove(void (*ptr)(void))
{
 880:	cf 93       	push	r28
 882:	df 93       	push	r29
 884:	00 d0       	rcall	.+0      	; 0x886 <Remove+0x6>
 886:	00 d0       	rcall	.+0      	; 0x888 <Remove+0x8>
 888:	cd b7       	in	r28, 0x3d	; 61
 88a:	de b7       	in	r29, 0x3e	; 62
 88c:	9c 83       	std	Y+4, r25	; 0x04
 88e:	8b 83       	std	Y+3, r24	; 0x03
	uint8 i ,num ;
	for(i=0 ; i<index ; i++)/* loop from 0 to index too get the index of removed item */
 890:	19 82       	std	Y+1, r1	; 0x01
 892:	1b c0       	rjmp	.+54     	; 0x8ca <Remove+0x4a>
	{
		if(ptr==Task_Arr[i].ptr_func)/*search for task that will removed and save its index to overwrite on it */
 894:	89 81       	ldd	r24, Y+1	; 0x01
 896:	28 2f       	mov	r18, r24
 898:	30 e0       	ldi	r19, 0x00	; 0
 89a:	c9 01       	movw	r24, r18
 89c:	88 0f       	add	r24, r24
 89e:	99 1f       	adc	r25, r25
 8a0:	88 0f       	add	r24, r24
 8a2:	99 1f       	adc	r25, r25
 8a4:	88 0f       	add	r24, r24
 8a6:	99 1f       	adc	r25, r25
 8a8:	82 1b       	sub	r24, r18
 8aa:	93 0b       	sbc	r25, r19
 8ac:	8b 59       	subi	r24, 0x9B	; 155
 8ae:	9f 4f       	sbci	r25, 0xFF	; 255
 8b0:	fc 01       	movw	r30, r24
 8b2:	20 81       	ld	r18, Z
 8b4:	31 81       	ldd	r19, Z+1	; 0x01
 8b6:	8b 81       	ldd	r24, Y+3	; 0x03
 8b8:	9c 81       	ldd	r25, Y+4	; 0x04
 8ba:	28 17       	cp	r18, r24
 8bc:	39 07       	cpc	r19, r25
 8be:	11 f4       	brne	.+4      	; 0x8c4 <Remove+0x44>
		{
			num=i;/*store the value of index in removed item in Task_arr in num variable */
 8c0:	89 81       	ldd	r24, Y+1	; 0x01
 8c2:	8a 83       	std	Y+2, r24	; 0x02
/* function takes pointer to fun for the removed element in array of structure and i receive the address of fun and store it in pointer to fun 
to use this to detect the index of the removed element   */
void Remove(void (*ptr)(void))
{
	uint8 i ,num ;
	for(i=0 ; i<index ; i++)/* loop from 0 to index too get the index of removed item */
 8c4:	89 81       	ldd	r24, Y+1	; 0x01
 8c6:	8f 5f       	subi	r24, 0xFF	; 255
 8c8:	89 83       	std	Y+1, r24	; 0x01
 8ca:	89 81       	ldd	r24, Y+1	; 0x01
 8cc:	28 2f       	mov	r18, r24
 8ce:	30 e0       	ldi	r19, 0x00	; 0
 8d0:	40 e0       	ldi	r20, 0x00	; 0
 8d2:	50 e0       	ldi	r21, 0x00	; 0
 8d4:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 8d8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 8dc:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 8e0:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 8e4:	28 17       	cp	r18, r24
 8e6:	39 07       	cpc	r19, r25
 8e8:	4a 07       	cpc	r20, r26
 8ea:	5b 07       	cpc	r21, r27
 8ec:	98 f2       	brcs	.-90     	; 0x894 <Remove+0x14>
		if(ptr==Task_Arr[i].ptr_func)/*search for task that will removed and save its index to overwrite on it */
		{
			num=i;/*store the value of index in removed item in Task_arr in num variable */
		}
	}
	for(i=num ; i<index ; i++)
 8ee:	8a 81       	ldd	r24, Y+2	; 0x02
 8f0:	89 83       	std	Y+1, r24	; 0x01
 8f2:	95 c0       	rjmp	.+298    	; 0xa1e <Remove+0x19e>
	{
		/*shift the elements with removed element */
		Task_Arr[i].ptr_func=Task_Arr[i+1].ptr_func;
 8f4:	89 81       	ldd	r24, Y+1	; 0x01
 8f6:	28 2f       	mov	r18, r24
 8f8:	30 e0       	ldi	r19, 0x00	; 0
 8fa:	89 81       	ldd	r24, Y+1	; 0x01
 8fc:	88 2f       	mov	r24, r24
 8fe:	90 e0       	ldi	r25, 0x00	; 0
 900:	ac 01       	movw	r20, r24
 902:	4f 5f       	subi	r20, 0xFF	; 255
 904:	5f 4f       	sbci	r21, 0xFF	; 255
 906:	ca 01       	movw	r24, r20
 908:	88 0f       	add	r24, r24
 90a:	99 1f       	adc	r25, r25
 90c:	88 0f       	add	r24, r24
 90e:	99 1f       	adc	r25, r25
 910:	88 0f       	add	r24, r24
 912:	99 1f       	adc	r25, r25
 914:	84 1b       	sub	r24, r20
 916:	95 0b       	sbc	r25, r21
 918:	8b 59       	subi	r24, 0x9B	; 155
 91a:	9f 4f       	sbci	r25, 0xFF	; 255
 91c:	fc 01       	movw	r30, r24
 91e:	40 81       	ld	r20, Z
 920:	51 81       	ldd	r21, Z+1	; 0x01
 922:	c9 01       	movw	r24, r18
 924:	88 0f       	add	r24, r24
 926:	99 1f       	adc	r25, r25
 928:	88 0f       	add	r24, r24
 92a:	99 1f       	adc	r25, r25
 92c:	88 0f       	add	r24, r24
 92e:	99 1f       	adc	r25, r25
 930:	82 1b       	sub	r24, r18
 932:	93 0b       	sbc	r25, r19
 934:	8b 59       	subi	r24, 0x9B	; 155
 936:	9f 4f       	sbci	r25, 0xFF	; 255
 938:	fc 01       	movw	r30, r24
 93a:	51 83       	std	Z+1, r21	; 0x01
 93c:	40 83       	st	Z, r20
		Task_Arr[i].Task_Periodicity=Task_Arr[i+1].Task_Periodicity;
 93e:	89 81       	ldd	r24, Y+1	; 0x01
 940:	28 2f       	mov	r18, r24
 942:	30 e0       	ldi	r19, 0x00	; 0
 944:	89 81       	ldd	r24, Y+1	; 0x01
 946:	88 2f       	mov	r24, r24
 948:	90 e0       	ldi	r25, 0x00	; 0
 94a:	ac 01       	movw	r20, r24
 94c:	4f 5f       	subi	r20, 0xFF	; 255
 94e:	5f 4f       	sbci	r21, 0xFF	; 255
 950:	ca 01       	movw	r24, r20
 952:	88 0f       	add	r24, r24
 954:	99 1f       	adc	r25, r25
 956:	88 0f       	add	r24, r24
 958:	99 1f       	adc	r25, r25
 95a:	88 0f       	add	r24, r24
 95c:	99 1f       	adc	r25, r25
 95e:	84 1b       	sub	r24, r20
 960:	95 0b       	sbc	r25, r21
 962:	89 59       	subi	r24, 0x99	; 153
 964:	9f 4f       	sbci	r25, 0xFF	; 255
 966:	fc 01       	movw	r30, r24
 968:	40 81       	ld	r20, Z
 96a:	51 81       	ldd	r21, Z+1	; 0x01
 96c:	c9 01       	movw	r24, r18
 96e:	88 0f       	add	r24, r24
 970:	99 1f       	adc	r25, r25
 972:	88 0f       	add	r24, r24
 974:	99 1f       	adc	r25, r25
 976:	88 0f       	add	r24, r24
 978:	99 1f       	adc	r25, r25
 97a:	82 1b       	sub	r24, r18
 97c:	93 0b       	sbc	r25, r19
 97e:	89 59       	subi	r24, 0x99	; 153
 980:	9f 4f       	sbci	r25, 0xFF	; 255
 982:	fc 01       	movw	r30, r24
 984:	51 83       	std	Z+1, r21	; 0x01
 986:	40 83       	st	Z, r20
		Task_Arr[i].Remaining_Ticks=Task_Arr[i+1].Remaining_Ticks;
 988:	89 81       	ldd	r24, Y+1	; 0x01
 98a:	28 2f       	mov	r18, r24
 98c:	30 e0       	ldi	r19, 0x00	; 0
 98e:	89 81       	ldd	r24, Y+1	; 0x01
 990:	88 2f       	mov	r24, r24
 992:	90 e0       	ldi	r25, 0x00	; 0
 994:	ac 01       	movw	r20, r24
 996:	4f 5f       	subi	r20, 0xFF	; 255
 998:	5f 4f       	sbci	r21, 0xFF	; 255
 99a:	ca 01       	movw	r24, r20
 99c:	88 0f       	add	r24, r24
 99e:	99 1f       	adc	r25, r25
 9a0:	88 0f       	add	r24, r24
 9a2:	99 1f       	adc	r25, r25
 9a4:	88 0f       	add	r24, r24
 9a6:	99 1f       	adc	r25, r25
 9a8:	84 1b       	sub	r24, r20
 9aa:	95 0b       	sbc	r25, r21
 9ac:	87 59       	subi	r24, 0x97	; 151
 9ae:	9f 4f       	sbci	r25, 0xFF	; 255
 9b0:	fc 01       	movw	r30, r24
 9b2:	40 81       	ld	r20, Z
 9b4:	51 81       	ldd	r21, Z+1	; 0x01
 9b6:	c9 01       	movw	r24, r18
 9b8:	88 0f       	add	r24, r24
 9ba:	99 1f       	adc	r25, r25
 9bc:	88 0f       	add	r24, r24
 9be:	99 1f       	adc	r25, r25
 9c0:	88 0f       	add	r24, r24
 9c2:	99 1f       	adc	r25, r25
 9c4:	82 1b       	sub	r24, r18
 9c6:	93 0b       	sbc	r25, r19
 9c8:	87 59       	subi	r24, 0x97	; 151
 9ca:	9f 4f       	sbci	r25, 0xFF	; 255
 9cc:	fc 01       	movw	r30, r24
 9ce:	51 83       	std	Z+1, r21	; 0x01
 9d0:	40 83       	st	Z, r20
		Task_Arr[i].priority=Task_Arr[i+1].priority;
 9d2:	89 81       	ldd	r24, Y+1	; 0x01
 9d4:	28 2f       	mov	r18, r24
 9d6:	30 e0       	ldi	r19, 0x00	; 0
 9d8:	89 81       	ldd	r24, Y+1	; 0x01
 9da:	88 2f       	mov	r24, r24
 9dc:	90 e0       	ldi	r25, 0x00	; 0
 9de:	ac 01       	movw	r20, r24
 9e0:	4f 5f       	subi	r20, 0xFF	; 255
 9e2:	5f 4f       	sbci	r21, 0xFF	; 255
 9e4:	ca 01       	movw	r24, r20
 9e6:	88 0f       	add	r24, r24
 9e8:	99 1f       	adc	r25, r25
 9ea:	88 0f       	add	r24, r24
 9ec:	99 1f       	adc	r25, r25
 9ee:	88 0f       	add	r24, r24
 9f0:	99 1f       	adc	r25, r25
 9f2:	84 1b       	sub	r24, r20
 9f4:	95 0b       	sbc	r25, r21
 9f6:	85 59       	subi	r24, 0x95	; 149
 9f8:	9f 4f       	sbci	r25, 0xFF	; 255
 9fa:	fc 01       	movw	r30, r24
 9fc:	40 81       	ld	r20, Z
 9fe:	c9 01       	movw	r24, r18
 a00:	88 0f       	add	r24, r24
 a02:	99 1f       	adc	r25, r25
 a04:	88 0f       	add	r24, r24
 a06:	99 1f       	adc	r25, r25
 a08:	88 0f       	add	r24, r24
 a0a:	99 1f       	adc	r25, r25
 a0c:	82 1b       	sub	r24, r18
 a0e:	93 0b       	sbc	r25, r19
 a10:	85 59       	subi	r24, 0x95	; 149
 a12:	9f 4f       	sbci	r25, 0xFF	; 255
 a14:	fc 01       	movw	r30, r24
 a16:	40 83       	st	Z, r20
		if(ptr==Task_Arr[i].ptr_func)/*search for task that will removed and save its index to overwrite on it */
		{
			num=i;/*store the value of index in removed item in Task_arr in num variable */
		}
	}
	for(i=num ; i<index ; i++)
 a18:	89 81       	ldd	r24, Y+1	; 0x01
 a1a:	8f 5f       	subi	r24, 0xFF	; 255
 a1c:	89 83       	std	Y+1, r24	; 0x01
 a1e:	89 81       	ldd	r24, Y+1	; 0x01
 a20:	28 2f       	mov	r18, r24
 a22:	30 e0       	ldi	r19, 0x00	; 0
 a24:	40 e0       	ldi	r20, 0x00	; 0
 a26:	50 e0       	ldi	r21, 0x00	; 0
 a28:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 a2c:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 a30:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 a34:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 a38:	28 17       	cp	r18, r24
 a3a:	39 07       	cpc	r19, r25
 a3c:	4a 07       	cpc	r20, r26
 a3e:	5b 07       	cpc	r21, r27
 a40:	08 f4       	brcc	.+2      	; 0xa44 <Remove+0x1c4>
 a42:	58 cf       	rjmp	.-336    	; 0x8f4 <Remove+0x74>
		Task_Arr[i].ptr_func=Task_Arr[i+1].ptr_func;
		Task_Arr[i].Task_Periodicity=Task_Arr[i+1].Task_Periodicity;
		Task_Arr[i].Remaining_Ticks=Task_Arr[i+1].Remaining_Ticks;
		Task_Arr[i].priority=Task_Arr[i+1].priority;
	}
	index--;/*decrement index cause i remove element */
 a44:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <index>
 a48:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <index+0x1>
 a4c:	a0 91 63 00 	lds	r26, 0x0063	; 0x800063 <index+0x2>
 a50:	b0 91 64 00 	lds	r27, 0x0064	; 0x800064 <index+0x3>
 a54:	01 97       	sbiw	r24, 0x01	; 1
 a56:	a1 09       	sbc	r26, r1
 a58:	b1 09       	sbc	r27, r1
 a5a:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <index>
 a5e:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <index+0x1>
 a62:	a0 93 63 00 	sts	0x0063, r26	; 0x800063 <index+0x2>
 a66:	b0 93 64 00 	sts	0x0064, r27	; 0x800064 <index+0x3>
 a6a:	00 00       	nop
 a6c:	0f 90       	pop	r0
 a6e:	0f 90       	pop	r0
 a70:	0f 90       	pop	r0
 a72:	0f 90       	pop	r0
 a74:	df 91       	pop	r29
 a76:	cf 91       	pop	r28
 a78:	08 95       	ret

00000a7a <GO>:
#include "../includes/Task.h"
void GO(void)
{
 a7a:	cf 93       	push	r28
 a7c:	df 93       	push	r29
 a7e:	cd b7       	in	r28, 0x3d	; 61
 a80:	de b7       	in	r29, 0x3e	; 62
	DIO_WritePin(LED1,HIGH); /*GO State*/
 a82:	61 e0       	ldi	r22, 0x01	; 1
 a84:	8d e0       	ldi	r24, 0x0D	; 13
 a86:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(LED2,LOW);
 a8a:	60 e0       	ldi	r22, 0x00	; 0
 a8c:	8e e0       	ldi	r24, 0x0E	; 14
 a8e:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(LED3,LOW);	
 a92:	60 e0       	ldi	r22, 0x00	; 0
 a94:	8f e0       	ldi	r24, 0x0F	; 15
 a96:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
}
 a9a:	00 00       	nop
 a9c:	df 91       	pop	r29
 a9e:	cf 91       	pop	r28
 aa0:	08 95       	ret

00000aa2 <STOP>:
void STOP(void)
{
 aa2:	cf 93       	push	r28
 aa4:	df 93       	push	r29
 aa6:	cd b7       	in	r28, 0x3d	; 61
 aa8:	de b7       	in	r29, 0x3e	; 62
	DIO_WritePin(LED1,LOW); /*STOP State*/
 aaa:	60 e0       	ldi	r22, 0x00	; 0
 aac:	8d e0       	ldi	r24, 0x0D	; 13
 aae:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(LED2,LOW);
 ab2:	60 e0       	ldi	r22, 0x00	; 0
 ab4:	8e e0       	ldi	r24, 0x0E	; 14
 ab6:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(LED3,HIGH);	
 aba:	61 e0       	ldi	r22, 0x01	; 1
 abc:	8f e0       	ldi	r24, 0x0F	; 15
 abe:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>

}
 ac2:	00 00       	nop
 ac4:	df 91       	pop	r29
 ac6:	cf 91       	pop	r28
 ac8:	08 95       	ret

00000aca <READY>:
void READY(void)
{	
 aca:	cf 93       	push	r28
 acc:	df 93       	push	r29
 ace:	cd b7       	in	r28, 0x3d	; 61
 ad0:	de b7       	in	r29, 0x3e	; 62
	DIO_WritePin(LED1,LOW); /*STOP State*/
 ad2:	60 e0       	ldi	r22, 0x00	; 0
 ad4:	8d e0       	ldi	r24, 0x0D	; 13
 ad6:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
    DIO_WritePin(LED2,HIGH);
 ada:	61 e0       	ldi	r22, 0x01	; 1
 adc:	8e e0       	ldi	r24, 0x0E	; 14
 ade:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(LED3,LOW);	
 ae2:	60 e0       	ldi	r22, 0x00	; 0
 ae4:	8f e0       	ldi	r24, 0x0F	; 15
 ae6:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>

}
 aea:	00 00       	nop
 aec:	df 91       	pop	r29
 aee:	cf 91       	pop	r28
 af0:	08 95       	ret

00000af2 <__vector_10>:
volatile uint16 g_tick = NUMBER_ZERO;  /* FLAG FOR TIMER ZERO COMPRE INTERRUPT */
void (*global_ptr)(void);/*GLOBAL POINTER TO STORE THE ADDRESS OF CALL BACK FUNCTION AND USE IT INSIDE isr */

/* Interrupt Service Routine for timer0 compare mode */
ISR(TIMER0_COMP_vect)
{
 af2:	1f 92       	push	r1
 af4:	0f 92       	push	r0
 af6:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 afa:	0f 92       	push	r0
 afc:	11 24       	eor	r1, r1
 afe:	2f 93       	push	r18
 b00:	3f 93       	push	r19
 b02:	4f 93       	push	r20
 b04:	5f 93       	push	r21
 b06:	6f 93       	push	r22
 b08:	7f 93       	push	r23
 b0a:	8f 93       	push	r24
 b0c:	9f 93       	push	r25
 b0e:	af 93       	push	r26
 b10:	bf 93       	push	r27
 b12:	ef 93       	push	r30
 b14:	ff 93       	push	r31
 b16:	cf 93       	push	r28
 b18:	df 93       	push	r29
 b1a:	cd b7       	in	r28, 0x3d	; 61
 b1c:	de b7       	in	r29, 0x3e	; 62
		global_ptr();
 b1e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <global_ptr>
 b22:	90 91 7b 00 	lds	r25, 0x007B	; 0x80007b <global_ptr+0x1>
 b26:	fc 01       	movw	r30, r24
 b28:	09 95       	icall
		
}
 b2a:	00 00       	nop
 b2c:	df 91       	pop	r29
 b2e:	cf 91       	pop	r28
 b30:	ff 91       	pop	r31
 b32:	ef 91       	pop	r30
 b34:	bf 91       	pop	r27
 b36:	af 91       	pop	r26
 b38:	9f 91       	pop	r25
 b3a:	8f 91       	pop	r24
 b3c:	7f 91       	pop	r23
 b3e:	6f 91       	pop	r22
 b40:	5f 91       	pop	r21
 b42:	4f 91       	pop	r20
 b44:	3f 91       	pop	r19
 b46:	2f 91       	pop	r18
 b48:	0f 90       	pop	r0
 b4a:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 b4e:	0f 90       	pop	r0
 b50:	1f 90       	pop	r1
 b52:	18 95       	reti

00000b54 <set_call_back>:
/* O/p : N/A */
/* Return : void */
/* Function that takes pointer to fun to use it inside ISR */

void set_call_back(void (*gptr)(void))
{
 b54:	cf 93       	push	r28
 b56:	df 93       	push	r29
 b58:	00 d0       	rcall	.+0      	; 0xb5a <set_call_back+0x6>
 b5a:	cd b7       	in	r28, 0x3d	; 61
 b5c:	de b7       	in	r29, 0x3e	; 62
 b5e:	9a 83       	std	Y+2, r25	; 0x02
 b60:	89 83       	std	Y+1, r24	; 0x01
	global_ptr=gptr;
 b62:	89 81       	ldd	r24, Y+1	; 0x01
 b64:	9a 81       	ldd	r25, Y+2	; 0x02
 b66:	90 93 7b 00 	sts	0x007B, r25	; 0x80007b <global_ptr+0x1>
 b6a:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <global_ptr>
}
 b6e:	00 00       	nop
 b70:	0f 90       	pop	r0
 b72:	0f 90       	pop	r0
 b74:	df 91       	pop	r29
 b76:	cf 91       	pop	r28
 b78:	08 95       	ret

00000b7a <timer0_init_CTC_mode>:
/* I/p : N/A */
/* O/p : N/A */
/* Return : void */
/* Function that initialize timer zero */
void timer0_init_CTC_mode(void)
{
 b7a:	cf 93       	push	r28
 b7c:	df 93       	push	r29
 b7e:	cd b7       	in	r28, 0x3d	; 61
 b80:	de b7       	in	r29, 0x3e	; 62
	TCNT0=NUMBER_ZERO;/*timer register zero TCNT0 start from zero */
 b82:	82 e5       	ldi	r24, 0x52	; 82
 b84:	90 e0       	ldi	r25, 0x00	; 0
 b86:	fc 01       	movw	r30, r24
 b88:	10 82       	st	Z, r1
	OCR0=OCR0_VALUE_REGISTER;/*compare register value */
 b8a:	8c e5       	ldi	r24, 0x5C	; 92
 b8c:	90 e0       	ldi	r25, 0x00	; 0
 b8e:	2c e7       	ldi	r18, 0x7C	; 124
 b90:	fc 01       	movw	r30, r24
 b92:	20 83       	st	Z, r18
	TIMSK|=(NUMBER_ONE<<OCIE0);/*TIMER INTERRUPT ENABLE FOR COMPARE MATCH */
 b94:	89 e5       	ldi	r24, 0x59	; 89
 b96:	90 e0       	ldi	r25, 0x00	; 0
 b98:	29 e5       	ldi	r18, 0x59	; 89
 b9a:	30 e0       	ldi	r19, 0x00	; 0
 b9c:	f9 01       	movw	r30, r18
 b9e:	20 81       	ld	r18, Z
 ba0:	22 60       	ori	r18, 0x02	; 2
 ba2:	fc 01       	movw	r30, r24
 ba4:	20 83       	st	Z, r18
	TCCR0|= (NUMBER_ONE<<WGM01) | (NUMBER_ONE<<CS01) | (NUMBER_ONE<<CS00);/*prescaler */
 ba6:	83 e5       	ldi	r24, 0x53	; 83
 ba8:	90 e0       	ldi	r25, 0x00	; 0
 baa:	23 e5       	ldi	r18, 0x53	; 83
 bac:	30 e0       	ldi	r19, 0x00	; 0
 bae:	f9 01       	movw	r30, r18
 bb0:	20 81       	ld	r18, Z
 bb2:	2b 60       	ori	r18, 0x0B	; 11
 bb4:	fc 01       	movw	r30, r24
 bb6:	20 83       	st	Z, r18
    Set_Bit(SREG,IBIT);/*ENABEL GLOBAL INTERRUPT BIT IN SREG REGISTER */
 bb8:	8f e5       	ldi	r24, 0x5F	; 95
 bba:	90 e0       	ldi	r25, 0x00	; 0
 bbc:	2f e5       	ldi	r18, 0x5F	; 95
 bbe:	30 e0       	ldi	r19, 0x00	; 0
 bc0:	f9 01       	movw	r30, r18
 bc2:	20 81       	ld	r18, Z
 bc4:	20 68       	ori	r18, 0x80	; 128
 bc6:	fc 01       	movw	r30, r24
 bc8:	20 83       	st	Z, r18
}
 bca:	00 00       	nop
 bcc:	df 91       	pop	r29
 bce:	cf 91       	pop	r28
 bd0:	08 95       	ret

00000bd2 <_exit>:
 bd2:	f8 94       	cli

00000bd4 <__stop_program>:
 bd4:	ff cf       	rjmp	.-2      	; 0xbd4 <__stop_program>
